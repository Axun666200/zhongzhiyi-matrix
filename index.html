<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>众之翼矩阵</title>
    <link rel="icon" type="image/png" href="images/2.png">
    <style>
        body {
            margin: 0;
            font-family: 'Microsoft YaHei', sans-serif;
            background: #000;
            color: #fff;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        .liquid-chrome-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #liquidChromeCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .content {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            text-align: center;
            background: rgba(0, 0, 0, 0.2);
            pointer-events: none; /* 让鼠标事件穿透到背景层 */
        }
        
        .title {
            font-size: 4rem;
            font-weight: bold;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, #00f5ff, #ff00ff, #ffff00);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient-shift 3s ease-in-out infinite;
            text-shadow: 0 0 30px rgba(0, 245, 255, 0.5);
        }
        
        .subtitle {
            font-size: 1.5rem;
            color: #00f5ff;
            margin-bottom: 2rem;
        }

        .controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
            pointer-events: auto; /* 恢复控制面板的指针事件 */
        }

        .btn {
            padding: 12px 44px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            pointer-events: auto;
            position: relative;
            overflow: hidden;
            font-weight: 600;
            letter-spacing: 0.5px;
            /* 赛博风格渐变文字 */
            background-image: linear-gradient(45deg, #f9fbfb, hsl(60, 7%, 97%), #fcfcfa, #faf7f7);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: cyber-text-flow 4s ease-in-out infinite;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 245, 255, 0.3), transparent);
            transition: left 0.5s;
        }
        
        .btn:hover {
            background-color: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.6);
            box-shadow: 
                0 0 25px rgba(0, 245, 255, 0.4),
                inset 0 0 20px rgba(0, 245, 255, 0.1);
            transform: translateY(-2px);
        }
        
        .btn:hover::before {
            left: 100%;
        }
        
        .btn:active {
            transform: translateY(0);
            box-shadow: 
                0 0 15px rgba(0, 245, 255, 0.6),
                inset 0 0 15px rgba(0, 245, 255, 0.2);
        }

        .interaction-controls {
            pointer-events: auto !important; /* 确保交互控制面板可以接收鼠标事件 */
        }

        .loading {
            color: #00f5ff;
            font-size: 1.2rem;
        }
        
        @keyframes gradient-shift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        @keyframes cyber-text-flow {
            0%, 100% { 
                background-position: 0% 50%; 
            }
            33% { 
                background-position: 100% 50%; 
            }
            66% { 
                background-position: 200% 50%; 
            }
        }
        
        @keyframes breathe {
            0%, 100% { 
                opacity: 0.7;
                transform: scale(0.98);
            }
            50% { 
                opacity: 1;
                transform: scale(1.05);
            }
        }
    </style>
</head>
<body>
    <div id="root">
        <div class="container">
            <div class="content">
                <div class="loading">🌌 加载Galaxy组件中...</div>
            </div>
        </div>
    </div>

    <!-- React CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Liquid Chrome WebGL Implementation -->
    <script>
        // Liquid Chrome WebGL组件实现
        class LiquidChrome {
            constructor(canvas, options = {}) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                
                if (!this.gl) {
                    console.error('WebGL not supported');
                    return;
                }

                // 配置参数
                this.baseColor = options.baseColor || [0.1, 0.1, 0.1];
                this.speed = options.speed || 1.0;
                this.amplitude = options.amplitude || 0.6;
                this.frequencyX = options.frequencyX || 3.0;
                this.frequencyY = options.frequencyY || 3.0;
                this.interactive = options.interactive !== false;

                // 鼠标位置
                this.mouseX = 0;
                this.mouseY = 0;
                
                // 时间变量
                this.time = 0;
                this.animationId = null;

                this.init();
                this.setupEventListeners();
                this.animate();
            }

            init() {
                const gl = this.gl;
                
                // 顶点着色器
                const vertexShaderSource = `
                    attribute vec2 a_position;
                    attribute vec2 a_texCoord;
                    varying vec2 v_texCoord;
                    
                    void main() {
                        gl_Position = vec4(a_position, 0.0, 1.0);
                        v_texCoord = a_texCoord;
                    }
                `;

                // 片段着色器
                const fragmentShaderSource = `
                    precision highp float;
                    
                    uniform float u_time;
                    uniform vec2 u_resolution;
                    uniform vec3 u_baseColor;
                    uniform float u_amplitude;
                    uniform float u_frequencyX;
                    uniform float u_frequencyY;
                    uniform vec2 u_mouse;
                    
                    varying vec2 v_texCoord;

                    vec4 renderImage(vec2 uvCoord) {
                        vec2 fragCoord = uvCoord * u_resolution;
                        vec2 uv = (2.0 * fragCoord - u_resolution) / min(u_resolution.x, u_resolution.y);

                        // 液态动画效果
                        for (float i = 1.0; i < 10.0; i++){
                            uv.x += u_amplitude / i * cos(i * u_frequencyX * uv.y + u_time + u_mouse.x * 3.14159);
                            uv.y += u_amplitude / i * cos(i * u_frequencyY * uv.x + u_time + u_mouse.y * 3.14159);
                        }

                        // 鼠标交互涟漪效果
                        vec2 diff = (uvCoord - u_mouse);
                        float dist = length(diff);
                        float falloff = exp(-dist * 20.0);
                        float ripple = sin(10.0 * dist - u_time * 2.0) * 0.03;
                        uv += (diff / (dist + 0.0001)) * ripple * falloff;

                        // Chrome金属色彩
                        vec3 color = u_baseColor / abs(sin(u_time - uv.y - uv.x));
                        
                        // 保持纯红色调，移除蓝白色混合
                        // 增强红色金属光泽
                        color = mix(color, vec3(1.0, 0.2, 0.1), 0.2);
                        color *= 1.3;
                        
                        return vec4(color, 1.0);
                    }

                    void main() {
                        vec4 col = vec4(0.0);
                        int samples = 0;
                        
                        // 抗锯齿采样
                        for (int i = -1; i <= 1; i++){
                            for (int j = -1; j <= 1; j++){
                                vec2 offset = vec2(float(i), float(j)) * (1.0 / min(u_resolution.x, u_resolution.y));
                                col += renderImage(v_texCoord + offset);
                                samples++;
                            }
                        }
                        
                        gl_FragColor = col / float(samples);
                    }
                `;

                // 创建着色器
                this.vertexShader = this.createShader(gl.VERTEX_SHADER, vertexShaderSource);
                this.fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
                
                // 创建程序
                this.program = this.createProgram(this.vertexShader, this.fragmentShader);
                
                // 获取attribute和uniform位置
                this.positionAttributeLocation = gl.getAttribLocation(this.program, 'a_position');
                this.texCoordAttributeLocation = gl.getAttribLocation(this.program, 'a_texCoord');
                
                this.timeUniformLocation = gl.getUniformLocation(this.program, 'u_time');
                this.resolutionUniformLocation = gl.getUniformLocation(this.program, 'u_resolution');
                this.baseColorUniformLocation = gl.getUniformLocation(this.program, 'u_baseColor');
                this.amplitudeUniformLocation = gl.getUniformLocation(this.program, 'u_amplitude');
                this.frequencyXUniformLocation = gl.getUniformLocation(this.program, 'u_frequencyX');
                this.frequencyYUniformLocation = gl.getUniformLocation(this.program, 'u_frequencyY');
                this.mouseUniformLocation = gl.getUniformLocation(this.program, 'u_mouse');

                // 创建全屏四边形
                this.setupGeometry();
                
                // 设置视口
                this.resize();
            }

            createShader(type, source) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                
                return shader;
            }

            createProgram(vertexShader, fragmentShader) {
                const gl = this.gl;
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('Program linking error:', gl.getProgramInfoLog(program));
                    gl.deleteProgram(program);
                    return null;
                }
                
                return program;
            }

            setupGeometry() {
                const gl = this.gl;
                
                // 全屏四边形顶点
                const positions = [
                    -1, -1,
                     1, -1,
                    -1,  1,
                    -1,  1,
                     1, -1,
                     1,  1,
                ];
                
                const texCoords = [
                    0, 0,
                    1, 0,
                    0, 1,
                    0, 1,
                    1, 0,
                    1, 1,
                ];

                // 创建缓冲区
                this.positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

                this.texCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);
            }

            setupEventListeners() {
                if (!this.interactive) return;

                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouseX = (e.clientX - rect.left) / rect.width;
                    this.mouseY = 1.0 - (e.clientY - rect.top) / rect.height;
                });

                this.canvas.addEventListener('touchmove', (e) => {
                    if (e.touches.length > 0) {
                        const touch = e.touches[0];
                        const rect = this.canvas.getBoundingClientRect();
                        this.mouseX = (touch.clientX - rect.left) / rect.width;
                        this.mouseY = 1.0 - (touch.clientY - rect.top) / rect.height;
                    }
                });

                window.addEventListener('resize', () => {
                    this.resize();
                });
            }

            resize() {
                const displayWidth = this.canvas.clientWidth;
                const displayHeight = this.canvas.clientHeight;

                if (this.canvas.width !== displayWidth || this.canvas.height !== displayHeight) {
                    this.canvas.width = displayWidth;
                    this.canvas.height = displayHeight;
                    this.gl.viewport(0, 0, displayWidth, displayHeight);
                }
            }

            render() {
                const gl = this.gl;
                
                // 清空画布
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                // 使用程序
                gl.useProgram(this.program);
                
                // 设置uniforms
                gl.uniform1f(this.timeUniformLocation, this.time * 0.001 * this.speed);
                gl.uniform2f(this.resolutionUniformLocation, this.canvas.width, this.canvas.height);
                gl.uniform3f(this.baseColorUniformLocation, ...this.baseColor);
                gl.uniform1f(this.amplitudeUniformLocation, this.amplitude);
                gl.uniform1f(this.frequencyXUniformLocation, this.frequencyX);
                gl.uniform1f(this.frequencyYUniformLocation, this.frequencyY);
                gl.uniform2f(this.mouseUniformLocation, this.mouseX, this.mouseY);
                
                // 设置attributes
                gl.enableVertexAttribArray(this.positionAttributeLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                gl.vertexAttribPointer(this.positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
                
                gl.enableVertexAttribArray(this.texCoordAttributeLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
                gl.vertexAttribPointer(this.texCoordAttributeLocation, 2, gl.FLOAT, false, 0, 0);
                
                // 绘制
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }

            animate() {
                this.time = performance.now();
                this.render();
                this.animationId = requestAnimationFrame(() => this.animate());
            }

            destroy() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                
                const gl = this.gl;
                if (gl && this.program) {
                    gl.deleteProgram(this.program);
                    gl.deleteShader(this.vertexShader);
                    gl.deleteShader(this.fragmentShader);
                    gl.deleteBuffer(this.positionBuffer);
                    gl.deleteBuffer(this.texCoordBuffer);
                }
            }
        }

        // 嵌入OGL库的核心部分（如果需要的话）
        const OGL = (() => {
            // 简化的OGL实现，专为Galaxy组件使用
            class Renderer {
                constructor(options = {}) {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    
                    if (!gl) {
                        throw new Error('WebGL not supported');
                    }
                    
                    this.gl = gl;
                    this.canvas = canvas;
                    
                    if (options.alpha !== false) {
                        canvas.style.background = 'transparent';
                    }
                    
                    gl.clearColor(0, 0, 0, 0);
                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                }
                
                setSize(width, height) {
                    this.canvas.width = width;
                    this.canvas.height = height;
                    this.canvas.style.width = width + 'px';
                    this.canvas.style.height = height + 'px';
                    this.gl.viewport(0, 0, width, height);
                }
                
                render({ scene }) {
                    this.gl.clear(this.gl.COLOR_BUFFER_BIT);
                    scene.render(this.gl);
                }
            }
            
            class Program {
                constructor(gl, { vertex, fragment, uniforms = {} }) {
                    this.gl = gl;
                    this.uniforms = uniforms;
                    
                    const vertexShader = this.createShader(gl.VERTEX_SHADER, vertex);
                    const fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragment);
                    
                    this.program = gl.createProgram();
                    gl.attachShader(this.program, vertexShader);
                    gl.attachShader(this.program, fragmentShader);
                    gl.linkProgram(this.program);
                    
                    if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
                        console.error('Program link error:', gl.getProgramInfoLog(this.program));
                    }
                    
                    this.uniformLocations = {};
                    this.attributeLocations = {};
                    
                    // 获取uniform位置
                    Object.keys(uniforms).forEach(name => {
                        this.uniformLocations[name] = gl.getUniformLocation(this.program, name);
                    });
                    
                    // 获取attribute位置
                    this.attributeLocations.position = gl.getAttribLocation(this.program, 'position');
                    this.attributeLocations.uv = gl.getAttribLocation(this.program, 'uv');
                }
                
                createShader(type, source) {
                    const shader = this.gl.createShader(type);
                    this.gl.shaderSource(shader, source);
                    this.gl.compileShader(shader);
                    
                    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                        console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
                    }
                    
                    return shader;
                }
            }
            
            class Mesh {
                constructor(gl, { geometry, program }) {
                    this.gl = gl;
                    this.geometry = geometry;
                    this.program = program;
                }
                
                render(gl) {
                    gl.useProgram(this.program.program);
                    
                    // 设置uniforms
                    Object.keys(this.program.uniforms).forEach(name => {
                        const uniform = this.program.uniforms[name];
                        const location = this.program.uniformLocations[name];
                        
                        if (location !== null) {
                            if (uniform.value instanceof Float32Array) {
                                if (uniform.value.length === 2) {
                                    gl.uniform2fv(location, uniform.value);
                                } else if (uniform.value.length === 3) {
                                    gl.uniform3fv(location, uniform.value);
                                }
                            } else if (typeof uniform.value === 'boolean') {
                                gl.uniform1i(location, uniform.value ? 1 : 0);
                            } else if (typeof uniform.value === 'number') {
                                gl.uniform1f(location, uniform.value);
                            } else if (uniform.value && uniform.value.r !== undefined) {
                                // Color object
                                gl.uniform3f(location, uniform.value.r, uniform.value.g, uniform.value.b);
                            }
                        }
                    });
                    
                    // 绑定几何体
                    this.geometry.render(gl, this.program);
                }
            }
            
            class Triangle {
                constructor(gl) {
                    this.gl = gl;
                    
                    // 创建全屏三角形
                    const positions = new Float32Array([
                        -1, -1,
                         3, -1,
                        -1,  3
                    ]);
                    
                    const uvs = new Float32Array([
                        0, 0,
                        2, 0,
                        0, 2
                    ]);
                    
                    this.positionBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
                    
                    this.uvBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, uvs, gl.STATIC_DRAW);
                }
                
                render(gl, program) {
                    // 位置属性
                    if (program.attributeLocations.position !== -1) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                        gl.enableVertexAttribArray(program.attributeLocations.position);
                        gl.vertexAttribPointer(program.attributeLocations.position, 2, gl.FLOAT, false, 0, 0);
                    }
                    
                    // UV属性
                    if (program.attributeLocations.uv !== -1) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
                        gl.enableVertexAttribArray(program.attributeLocations.uv);
                        gl.vertexAttribPointer(program.attributeLocations.uv, 2, gl.FLOAT, false, 0, 0);
                    }
                    
                    gl.drawArrays(gl.TRIANGLES, 0, 3);
                }
            }
            
            class Color {
                constructor(r, g, b) {
                    this.r = r;
                    this.g = g;
                    this.b = b;
                }
            }
            
            return {
                Renderer,
                Program,
                Mesh,
                Triangle,
                Color
            };
        })();
        
        console.log('OGL库已加载:', OGL);
    </script>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const { Renderer, Program, Mesh, Color, Triangle } = OGL;

        // Galaxy组件
        function Galaxy({
          focal = [0.5, 0.5],
          rotation = [1.0, 0.0],
          starSpeed = 0.5,
          density = 1.5,
          hueShift = 240,
          disableAnimation = false,
          speed = 1.0,
          mouseInteraction = true,
          glowIntensity = 0.5,
          saturation = 0.8,
          mouseRepulsion = true,
          repulsionStrength = 2,
          twinkleIntensity = 0.3,
          rotationSpeed = 0.1,
          autoCenterRepulsion = 0,
          transparent = true,
          testMode = false,
          ...rest
        }) {
          const ctnDom = useRef(null);
          const targetMousePos = useRef({ x: 0.5, y: 0.5 });
          const smoothMousePos = useRef({ x: 0.5, y: 0.5 });
          const targetMouseActive = useRef(0.0);
          const smoothMouseActive = useRef(0.0);

          const vertexShader = `
          attribute vec2 uv;
          attribute vec2 position;
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = vec4(position, 0, 1);
          }
          `;

          const fragmentShader = `
          precision highp float;
          uniform float uTime;
          uniform vec3 uResolution;
          uniform vec2 uFocal;
          uniform vec2 uRotation;
          uniform float uStarSpeed;
          uniform float uDensity;
          uniform float uHueShift;
          uniform float uSpeed;
          uniform vec2 uMouse;
          uniform float uGlowIntensity;
          uniform float uSaturation;
          uniform bool uMouseRepulsion;
          uniform float uTwinkleIntensity;
          uniform float uRotationSpeed;
          uniform float uRepulsionStrength;
          uniform float uMouseActiveFactor;
          uniform float uAutoCenterRepulsion;
          uniform bool uTransparent;
          varying vec2 vUv;

          #define NUM_LAYER 4.0
          #define STAR_COLOR_CUTOFF 0.2
          #define MAT45 mat2(0.7071, -0.7071, 0.7071, 0.7071)
          #define PERIOD 3.0

          float Hash21(vec2 p) {
            p = fract(p * vec2(123.34, 456.21));
            p += dot(p, p + 45.32);
            return fract(p.x * p.y);
          }

          float tri(float x) {
            return abs(fract(x) * 2.0 - 1.0);
          }

          float tris(float x) {
            float t = fract(x);
            return 1.0 - smoothstep(0.0, 1.0, abs(2.0 * t - 1.0));
          }

          float trisn(float x) {
            float t = fract(x);
            return 2.0 * (1.0 - smoothstep(0.0, 1.0, abs(2.0 * t - 1.0))) - 1.0;
          }

          vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
          }

          float Star(vec2 uv, float flare) {
            float d = length(uv);
            float m = (0.05 * uGlowIntensity) / d;
            float rays = smoothstep(0.0, 1.0, 1.0 - abs(uv.x * uv.y * 1000.0));
            m += rays * flare * uGlowIntensity;
            uv *= MAT45;
            rays = smoothstep(0.0, 1.0, 1.0 - abs(uv.x * uv.y * 1000.0));
            m += rays * 0.3 * flare * uGlowIntensity;
            m *= smoothstep(1.0, 0.2, d);
            return m;
          }

          vec3 StarLayer(vec2 uv) {
            vec3 col = vec3(0.0);
            vec2 gv = fract(uv) - 0.5; 
            vec2 id = floor(uv);

            for (int y = -1; y <= 1; y++) {
              for (int x = -1; x <= 1; x++) {
                vec2 offset = vec2(float(x), float(y));
                vec2 si = id + vec2(float(x), float(y));
                float seed = Hash21(si);
                float size = fract(seed * 345.32);
                float glossLocal = tri(uStarSpeed / (PERIOD * seed + 1.0));
                float flareSize = smoothstep(0.9, 1.0, size) * glossLocal;

                                // 三色星空系统：暖色主导 + 蓝色深空 + 白色点缀
                float colorSeed = Hash21(si + 7.0);
                float brightnessSeed = Hash21(si + 11.0);
                vec3 base;
                
                if (colorSeed < 0.35) {
                  // 蓝色系星体 (35%) - 深空辅助色调
                  if (brightnessSeed > 0.8) {
                    base = vec3(0.7, 0.85, 1.0); // 明亮冰蓝
                  } else if (brightnessSeed > 0.4) {
                    base = vec3(0.6, 0.75, 0.95); // 中等蓝白
                } else {
                    base = vec3(0.5, 0.65, 0.9); // 深蓝色
                  }
                } else if (colorSeed < 0.5) {
                  // 白色系星体 (15%) - 纯净点缀
                  if (brightnessSeed > 0.7) {
                    base = vec3(1.0, 1.0, 1.0); // 纯白色
                  } else if (brightnessSeed > 0.3) {
                    base = vec3(0.95, 0.97, 1.0); // 冷白色
                  } else {
                    base = vec3(0.9, 0.9, 0.9); // 银白色
                  }
                } else {
                  // 暖色系星体 (50%) - 主导温暖色调
                  if (brightnessSeed > 0.8) {
                    base = vec3(1.0, 0.65, 0.3); // 明亮金橙
                  } else if (brightnessSeed > 0.6) {
                    base = vec3(1.0, 0.7, 0.4); // 金橙色
                  } else if (brightnessSeed > 0.4) {
                    base = vec3(1.0, 0.8, 0.6); // 琥珀色
                  } else if (brightnessSeed > 0.2) {
                    base = vec3(1.0, 0.85, 0.7); // 暖黄色
                  } else {
                    base = vec3(0.9, 0.6, 0.4); // 深橙红色
                  }
                }

                vec2 pad = vec2(tris(seed * 34.0 + uTime * uSpeed / 10.0), tris(seed * 38.0 + uTime * uSpeed / 30.0)) - 0.5;

                float star = Star(gv - offset - pad, flareSize);
                vec3 color = base;

                float twinkle = trisn(uTime * uSpeed + seed * 6.2831) * 0.5 + 1.0;
                twinkle = mix(1.0, twinkle, uTwinkleIntensity);
                star *= twinkle;
                
                col += star * size * color;
              }
            }
            return col;
          }

          void main() {
            vec2 focalPx = uFocal * uResolution.xy;
            vec2 uv = (vUv * uResolution.xy - focalPx) / uResolution.y;

            if (uMouseRepulsion) {
              vec2 mousePosUV = (uMouse * uResolution.xy - focalPx) / uResolution.y;
              float mouseDist = length(uv - mousePosUV);
              // 可见的交互效果：适中的影响范围和强度
              float influence = smoothstep(1.2, 0.0, mouseDist); // 扩大影响范围
              vec2 repulsion = normalize(uv - mousePosUV) * (uRepulsionStrength * 0.8 / (mouseDist + 0.2));
              uv += repulsion * 0.05 * uMouseActiveFactor * influence; // 增加整体强度
            }

            float autoRotAngle = uTime * uRotationSpeed;
            mat2 autoRot = mat2(cos(autoRotAngle), -sin(autoRotAngle), sin(autoRotAngle), cos(autoRotAngle));
            uv = autoRot * uv;

            uv = mat2(uRotation.x, -uRotation.y, uRotation.y, uRotation.x) * uv;

            // 深蓝色背景渐变
            float distFromCenter = length(uv);
            vec3 backgroundColor = mix(
              vec3(0.02, 0.05, 0.15), // 中心深蓝色
              vec3(0.01, 0.02, 0.08), // 边缘更深蓝色
              smoothstep(0.0, 2.0, distFromCenter)
            );
            
            vec3 col = backgroundColor;

            for (float i = 0.0; i < 1.0; i += 1.0 / NUM_LAYER) {
              float depth = fract(i + uStarSpeed * uSpeed);
              float scale = mix(20.0 * uDensity, 0.5 * uDensity, depth);
              float fade = depth * smoothstep(1.0, 0.9, depth);
              col += StarLayer(uv * scale + i * 453.32) * fade;
            }

            float alpha = length(col - backgroundColor) + 0.8; // 保持一定的背景透明度
            alpha = smoothstep(0.0, 0.5, alpha);
            alpha = min(alpha, 1.0);
            gl_FragColor = vec4(col, alpha);
          }
          `;

          useEffect(() => {
            if (!ctnDom.current) return;
            const ctn = ctnDom.current;
            
            try {
              const renderer = new Renderer({
                alpha: transparent,
                premultipliedAlpha: false,
              });
              const gl = renderer.gl;

              let program;

              function resize() {
                const scale = 1;
                renderer.setSize(ctn.offsetWidth * scale, ctn.offsetHeight * scale);
                if (program) {
                  program.uniforms.uResolution.value = new Color(
                    gl.canvas.width,
                    gl.canvas.height,
                    gl.canvas.width / gl.canvas.height
                  );
                }
              }
              window.addEventListener("resize", resize, false);
              resize();

              const geometry = new Triangle(gl);
              program = new Program(gl, {
                vertex: vertexShader,
                fragment: fragmentShader,
                uniforms: {
                  uTime: { value: 0 },
                  uResolution: {
                    value: new Color(
                      gl.canvas.width,
                      gl.canvas.height,
                      gl.canvas.width / gl.canvas.height
                    ),
                  },
                  uFocal: { value: new Float32Array(focal) },
                  uRotation: { value: new Float32Array(rotation) },
                  uStarSpeed: { value: starSpeed },
                  uDensity: { value: density },
                  uHueShift: { value: hueShift },
                  uSpeed: { value: speed },
                  uMouse: {
                    value: new Float32Array([
                      smoothMousePos.current.x,
                      smoothMousePos.current.y,
                    ]),
                  },
                  uGlowIntensity: { value: glowIntensity },
                  uSaturation: { value: saturation },
                  uMouseRepulsion: { value: mouseRepulsion },
                  uTwinkleIntensity: { value: twinkleIntensity },
                  uRotationSpeed: { value: rotationSpeed },
                  uRepulsionStrength: { value: repulsionStrength },
                  uMouseActiveFactor: { value: 0.0 },
                  uAutoCenterRepulsion: { value: autoCenterRepulsion },
                  uTransparent: { value: transparent },
                },
              });

              const mesh = new Mesh(gl, { geometry, program });
              let animateId;

              function update(t) {
                animateId = requestAnimationFrame(update);
                if (!disableAnimation) {
                  program.uniforms.uTime.value = t * 0.001;
                  program.uniforms.uStarSpeed.value = (t * 0.001 * starSpeed) / 10.0;
                }

                // 测试模式：持续在中心位置施加强大的鼠标效果
                if (testMode) {
                  targetMousePos.current = { x: 0.5, y: 0.5 };
                  targetMouseActive.current = 3.0; // 强力效果
                  // 每2秒打印一次测试模式状态
                  if (Math.floor(t / 2000) !== Math.floor((t - 16) / 2000)) {
                    console.log('🧪 测试模式运行中: 持续强制效果');
                  }
                }

                const lerpFactor = 0.03; // 更平滑的过渡
                smoothMousePos.current.x +=
                  (targetMousePos.current.x - smoothMousePos.current.x) * lerpFactor;
                smoothMousePos.current.y +=
                  (targetMousePos.current.y - smoothMousePos.current.y) * lerpFactor;

                smoothMouseActive.current +=
                  (targetMouseActive.current - smoothMouseActive.current) * lerpFactor;

                program.uniforms.uMouse.value[0] = smoothMousePos.current.x;
                program.uniforms.uMouse.value[1] = smoothMousePos.current.y;
                program.uniforms.uMouseActiveFactor.value = smoothMouseActive.current;
                
                // 调试：每秒显示一次鼠标状态
                if (Math.floor(t / 1000) !== Math.floor((t - 16) / 1000)) {
                  console.log('Mouse state:', {
                    active: smoothMouseActive.current.toFixed(3),
                    pos: [smoothMousePos.current.x.toFixed(3), smoothMousePos.current.y.toFixed(3)],
                    repulsion: program.uniforms.uMouseRepulsion.value,
                    strength: program.uniforms.uRepulsionStrength.value
                  });
                }

                renderer.render({ scene: mesh });
              }
              animateId = requestAnimationFrame(update);
              ctn.appendChild(gl.canvas);
              
              console.log('Canvas info:', {
                element: gl.canvas,
                bounds: gl.canvas.getBoundingClientRect(),
                style: {
                  position: window.getComputedStyle(gl.canvas).position,
                  pointerEvents: window.getComputedStyle(gl.canvas).pointerEvents,
                  width: gl.canvas.style.width || gl.canvas.width,
                  height: gl.canvas.style.height || gl.canvas.height
                },
                parent: gl.canvas.parentElement
              });

              function handleMouseMove(e) {
                console.log('🔥 handleMouseMove triggered!', {
                  type: e.type,
                  clientX: e.clientX,
                  clientY: e.clientY,
                  target: e.target,
                  currentTarget: e.currentTarget
                });
                const rect = ctn.getBoundingClientRect();
                const x = (e.clientX - rect.left) / rect.width;
                const y = 1.0 - (e.clientY - rect.top) / rect.height;
                
                console.log('📍 计算的鼠标位置:', { x, y, rect: rect });
                
                // 只在非测试模式下更新鼠标位置
                if (!testMode) {
                  targetMousePos.current = { x, y };
                  targetMouseActive.current = 1.0;
                  console.log('✅ 更新鼠标状态:', {
                    position: targetMousePos.current,
                    active: targetMouseActive.current
                  });
                } else {
                  console.log('⚠️ 测试模式开启，忽略真实鼠标输入');
                }
              }

              function handleMouseLeave() {
                console.log('handleMouseLeave triggered!');
                targetMouseActive.current = 0.0;
              }

              console.log('Galaxy initialized with:', {
                mouseInteraction,
                mouseRepulsion,
                repulsionStrength,
                starSpeed,
                density,
                hueShift,
                glowIntensity,
                saturation
              });
              
              console.log('All uniforms:', Object.keys(program.uniforms).map(key => ({
                name: key,
                value: program.uniforms[key].value
              })));
              
              console.log('Container info:', {
                element: ctn,
                bounds: ctn.getBoundingClientRect(),
                style: {
                  position: window.getComputedStyle(ctn).position,
                  pointerEvents: window.getComputedStyle(ctn).pointerEvents,
                  width: window.getComputedStyle(ctn).width,
                  height: window.getComputedStyle(ctn).height
                }
              });

              // 添加一个通用的鼠标测试监听器
              function testMouseMove(e) {
                console.log('TEST: Mouse detected on container at', e.clientX, e.clientY);
              }
              ctn.addEventListener("mousemove", testMouseMove);
              
              if (mouseInteraction) {
                ctn.addEventListener("mousemove", handleMouseMove);
                ctn.addEventListener("mouseleave", handleMouseLeave);
                console.log('Mouse event listeners added to container');
              } else {
                console.log('Mouse interaction disabled');
              }

              return () => {
                cancelAnimationFrame(animateId);
                window.removeEventListener("resize", resize);
                ctn.removeEventListener("mousemove", testMouseMove);
                if (mouseInteraction) {
                  ctn.removeEventListener("mousemove", handleMouseMove);
                  ctn.removeEventListener("mouseleave", handleMouseLeave);
                }
                if (ctn.contains(gl.canvas)) {
                  ctn.removeChild(gl.canvas);
                }
                gl.getExtension("WEBGL_lose_context")?.loseContext();
              };
            } catch (error) {
              console.error('Galaxy组件初始化失败:', error);
            }
          }, [
            focal, rotation, starSpeed, density, hueShift, disableAnimation,
            speed, mouseInteraction, glowIntensity, saturation, mouseRepulsion,
            twinkleIntensity, rotationSpeed, repulsionStrength, autoCenterRepulsion, transparent, testMode,
          ]);

          return <div ref={ctnDom} style={{ width: '100%', height: '100%', position: 'relative' }} {...rest} />;
        }

        // 主应用组件
        function App() {
          const [config, setConfig] = useState({
            baseColor: [0.5, 0.1, 0.1],
            speed: 0.3,
            amplitude: 0.3,
            frequencyX: 3.0,
            frequencyY: 3.0,
            interactive: true
          });
          
          const [liquidChrome, setLiquidChrome] = useState(null);

          // 初始化LiquidChrome
          useEffect(() => {
            const canvas = document.getElementById('liquidChromeCanvas');
            if (canvas && !liquidChrome) {
              const chrome = new LiquidChrome(canvas, config);
              setLiquidChrome(chrome);
              
              return () => {
                if (chrome) {
                  chrome.destroy();
                }
              };
            }
          }, []);

          // 更新LiquidChrome配置
          useEffect(() => {
            if (liquidChrome) {
              liquidChrome.baseColor = config.baseColor;
              liquidChrome.speed = config.speed;
              liquidChrome.amplitude = config.amplitude;
              liquidChrome.frequencyX = config.frequencyX;
              liquidChrome.frequencyY = config.frequencyY;
              liquidChrome.interactive = config.interactive;
            }
          }, [config, liquidChrome]);

          const presets = [
           
          ];

          const applyPreset = (preset) => {
            setConfig({
              baseColor: preset.baseColor,
              speed: preset.speed,
              amplitude: preset.amplitude,
              frequencyX: preset.frequencyX,
              frequencyY: preset.frequencyY,
              interactive: true
            });
          };

          // 切换鼠标交互
          const toggleInteraction = () => {
            setConfig(prevConfig => ({
              ...prevConfig,
              interactive: !prevConfig.interactive
            }));
            console.log('鼠标交互已', !config.interactive ? '启用' : '禁用');
          };
          
          return (
            <div className="container">
              <div className="liquid-chrome-background">
                <canvas id="liquidChromeCanvas"></canvas>
                
                {/* 图片展示 - 在背景层 */}
                <div style={{ 
                  position: 'absolute',
                  top: '60px',
                  right: '580px',
                  zIndex: 10
                }}>
                  
                </div>
              </div>
              <div className="content">
                {/* 主标题区域 */}
                <div style={{
                  position: 'absolute',
                  top: '150px',
                  left: '50%',
                  transform: 'translateX(-50%)',
                  textAlign: 'center',
                  zIndex: 20,
                  maxWidth: '1000px',
                  width: '90%'
                }}>
                  {/* 英文标题 */}
                  <h1 style={{
                    fontSize: 'clamp(3rem, 8vw, 6rem)',
                    fontWeight: '800',
                    color: 'white',
                    textShadow: '0 4px 20px rgba(0, 0, 0, 0.5)',
                    marginBottom: '20px',
                    lineHeight: '1.1',
                    letterSpacing: '-0.02em'
                  }}>
                  The Dawn of Intelligent Creation！
                  </h1>
                  
                  {/* 中文标题 */}
                  <h2 style={{
                    fontSize: 'clamp(2rem, 5vw, 3.5rem)',
                    fontWeight: '700',
                    color: 'rgba(255, 255, 255, 0.9)',
                    textShadow: '0 2px 15px rgba(0, 0, 0, 0.4)',
                    marginBottom: '40px',
                    lineHeight: '1.2'
                  }}>
                  智能创作新纪元！
                  </h2>

                </div>

                
                {/* 进入主页按钮 */}
                <div style={{ marginTop: '480px', 
              marginLeft:'-15px'
                 }}>
                  <button
                    className="btn"
                    onClick={() => window.location.href = 'main.html'}
                                         style={{ 
                       backgroundColor: 'white',
                       fontSize: '18px',
                       padding: '15px 60px',
                       border: '2px solid rgba(255, 255, 255, 0.6)',
                       borderRadius: '30px',
                       color: 'white',
                       fontWeight: 'bold',
                       cursor: 'pointer',
                       transition: 'all 0.3s ease',
                       boxShadow: '0 0 20px rgba(255, 255, 255, 0.3)'
                     }}
                    onMouseEnter={(e) => {
                      e.target.style.backgroundColor = '#f0f0f0';
                      e.target.style.boxShadow = '0 0 30px rgba(255, 255, 255, 0.5)';
                      e.target.style.transform = 'scale(1.05)';
                    }}
                    onMouseLeave={(e) => {
                      e.target.style.backgroundColor = 'white';
                      e.target.style.boxShadow = '0 0 20px rgba(255, 255, 255, 0.3)';
                      e.target.style.transform = 'scale(1)';
                    }}
                  >
                     Get Started 开始
                  </button>
                </div>
              </div>
            </div>
          );
        }

        // 渲染应用 - 使用React 18 API
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>