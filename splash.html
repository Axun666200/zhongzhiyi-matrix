<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÂÖâÂ≠êÁü©Èòµ - Ê¨¢Ëøé</title>
    <style>
        body {
            margin: 0;
            font-family: 'Microsoft YaHei', sans-serif;
            background: #000;
            color: #fff;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        .galaxy-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .content {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            text-align: center;
            background: rgba(0, 0, 0, 0.2);
            pointer-events: none; /* ËÆ©Èº†Ê†á‰∫ã‰ª∂Á©øÈÄèÂà∞ËÉåÊôØÂ±Ç */
        }

        .title {
            font-size: 4rem;
            font-weight: bold;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, #00f5ff, #ff00ff, #ffff00);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient-shift 3s ease-in-out infinite;
            text-shadow: 0 0 30px rgba(0, 245, 255, 0.5);
        }

        .subtitle {
            font-size: 1.5rem;
            color: #00f5ff;
            margin-bottom: 2rem;
        }

        .controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
            pointer-events: auto; /* ÊÅ¢Â§çÊéßÂà∂Èù¢ÊùøÁöÑÊåáÈíà‰∫ã‰ª∂ */
        }

        .btn {
            padding: 10px 20px;
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid #00f5ff;
            color: #00f5ff;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            pointer-events: auto; /* ÊÅ¢Â§çÊåâÈíÆÁöÑÊåáÈíà‰∫ã‰ª∂ */
        }

        .btn:hover {
            background: rgba(0, 245, 255, 0.4);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.3);
        }

        .interaction-controls {
            pointer-events: auto !important; /* Á°Æ‰øù‰∫§‰∫íÊéßÂà∂Èù¢ÊùøÂèØ‰ª•Êé•Êî∂Èº†Ê†á‰∫ã‰ª∂ */
        }

        .loading {
            color: #00f5ff;
            font-size: 1.2rem;
        }

        @keyframes gradient-shift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
    </style>
</head>
<body>
    <div id="root">
        <div class="container">
            <div class="content">
                <div class="loading">üåå Âä†ËΩΩGalaxyÁªÑ‰ª∂‰∏≠...</div>
            </div>
        </div>
    </div>

    <!-- React CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Áõ¥Êé•ÂµåÂÖ•OGLÂ∫ì -->
    <script>
        // ÂµåÂÖ•OGLÂ∫ìÁöÑÊ†∏ÂøÉÈÉ®ÂàÜ
        const OGL = (() => {
            // ÁÆÄÂåñÁöÑOGLÂÆûÁé∞Ôºå‰∏ì‰∏∫GalaxyÁªÑ‰ª∂‰ΩøÁî®
            class Renderer {
                constructor(options = {}) {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    
                    if (!gl) {
                        throw new Error('WebGL not supported');
                    }
                    
                    this.gl = gl;
                    this.canvas = canvas;
                    
                    if (options.alpha !== false) {
                        canvas.style.background = 'transparent';
                    }
                    
                    gl.clearColor(0, 0, 0, 0);
                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                }
                
                setSize(width, height) {
                    this.canvas.width = width;
                    this.canvas.height = height;
                    this.canvas.style.width = width + 'px';
                    this.canvas.style.height = height + 'px';
                    this.gl.viewport(0, 0, width, height);
                }
                
                render({ scene }) {
                    this.gl.clear(this.gl.COLOR_BUFFER_BIT);
                    scene.render(this.gl);
                }
            }
            
            class Program {
                constructor(gl, { vertex, fragment, uniforms = {} }) {
                    this.gl = gl;
                    this.uniforms = uniforms;
                    
                    const vertexShader = this.createShader(gl.VERTEX_SHADER, vertex);
                    const fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragment);
                    
                    this.program = gl.createProgram();
                    gl.attachShader(this.program, vertexShader);
                    gl.attachShader(this.program, fragmentShader);
                    gl.linkProgram(this.program);
                    
                    if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
                        console.error('Program link error:', gl.getProgramInfoLog(this.program));
                    }
                    
                    this.uniformLocations = {};
                    this.attributeLocations = {};
                    
                    // Ëé∑Âèñuniform‰ΩçÁΩÆ
                    Object.keys(uniforms).forEach(name => {
                        this.uniformLocations[name] = gl.getUniformLocation(this.program, name);
                    });
                    
                    // Ëé∑Âèñattribute‰ΩçÁΩÆ
                    this.attributeLocations.position = gl.getAttribLocation(this.program, 'position');
                    this.attributeLocations.uv = gl.getAttribLocation(this.program, 'uv');
                }
                
                createShader(type, source) {
                    const shader = this.gl.createShader(type);
                    this.gl.shaderSource(shader, source);
                    this.gl.compileShader(shader);
                    
                    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                        console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
                    }
                    
                    return shader;
                }
            }
            
            class Mesh {
                constructor(gl, { geometry, program }) {
                    this.gl = gl;
                    this.geometry = geometry;
                    this.program = program;
                }
                
                render(gl) {
                    gl.useProgram(this.program.program);
                    
                    // ËÆæÁΩÆuniforms
                    Object.keys(this.program.uniforms).forEach(name => {
                        const uniform = this.program.uniforms[name];
                        const location = this.program.uniformLocations[name];
                        
                        if (location !== null) {
                            if (uniform.value instanceof Float32Array) {
                                if (uniform.value.length === 2) {
                                    gl.uniform2fv(location, uniform.value);
                                } else if (uniform.value.length === 3) {
                                    gl.uniform3fv(location, uniform.value);
                                }
                            } else if (typeof uniform.value === 'boolean') {
                                gl.uniform1i(location, uniform.value ? 1 : 0);
                            } else if (typeof uniform.value === 'number') {
                                gl.uniform1f(location, uniform.value);
                            } else if (uniform.value && uniform.value.r !== undefined) {
                                // Color object
                                gl.uniform3f(location, uniform.value.r, uniform.value.g, uniform.value.b);
                            }
                        }
                    });
                    
                    // ÁªëÂÆöÂá†‰Ωï‰Ωì
                    this.geometry.render(gl, this.program);
                }
            }
            
            class Triangle {
                constructor(gl) {
                    this.gl = gl;
                    
                    // ÂàõÂª∫ÂÖ®Â±è‰∏âËßíÂΩ¢
                    const positions = new Float32Array([
                        -1, -1,
                         3, -1,
                        -1,  3
                    ]);
                    
                    const uvs = new Float32Array([
                        0, 0,
                        2, 0,
                        0, 2
                    ]);
                    
                    this.positionBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
                    
                    this.uvBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, uvs, gl.STATIC_DRAW);
                }
                
                render(gl, program) {
                    // ‰ΩçÁΩÆÂ±ûÊÄß
                    if (program.attributeLocations.position !== -1) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                        gl.enableVertexAttribArray(program.attributeLocations.position);
                        gl.vertexAttribPointer(program.attributeLocations.position, 2, gl.FLOAT, false, 0, 0);
                    }
                    
                    // UVÂ±ûÊÄß
                    if (program.attributeLocations.uv !== -1) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
                        gl.enableVertexAttribArray(program.attributeLocations.uv);
                        gl.vertexAttribPointer(program.attributeLocations.uv, 2, gl.FLOAT, false, 0, 0);
                    }
                    
                    gl.drawArrays(gl.TRIANGLES, 0, 3);
                }
            }
            
            class Color {
                constructor(r, g, b) {
                    this.r = r;
                    this.g = g;
                    this.b = b;
                }
            }
            
            return {
                Renderer,
                Program,
                Mesh,
                Triangle,
                Color
            };
        })();
        
        console.log('OGLÂ∫ìÂ∑≤Âä†ËΩΩ:', OGL);
    </script>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const { Renderer, Program, Mesh, Color, Triangle } = OGL;

        // GalaxyÁªÑ‰ª∂
        function Galaxy({
          focal = [0.5, 0.5],
          rotation = [1.0, 0.0],
          starSpeed = 0.5,
          density = 1.5,
          hueShift = 240,
          disableAnimation = false,
          speed = 1.0,
          mouseInteraction = true,
          glowIntensity = 0.5,
          saturation = 0.8,
          mouseRepulsion = true,
          repulsionStrength = 2,
          twinkleIntensity = 0.3,
          rotationSpeed = 0.1,
          autoCenterRepulsion = 0,
          transparent = true,
          testMode = false,
          ...rest
        }) {
          const ctnDom = useRef(null);
          const targetMousePos = useRef({ x: 0.5, y: 0.5 });
          const smoothMousePos = useRef({ x: 0.5, y: 0.5 });
          const targetMouseActive = useRef(0.0);
          const smoothMouseActive = useRef(0.0);

          const vertexShader = `
          attribute vec2 uv;
          attribute vec2 position;
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = vec4(position, 0, 1);
          }
          `;

          const fragmentShader = `
          precision highp float;
          uniform float uTime;
          uniform vec3 uResolution;
          uniform vec2 uFocal;
          uniform vec2 uRotation;
          uniform float uStarSpeed;
          uniform float uDensity;
          uniform float uHueShift;
          uniform float uSpeed;
          uniform vec2 uMouse;
          uniform float uGlowIntensity;
          uniform float uSaturation;
          uniform bool uMouseRepulsion;
          uniform float uTwinkleIntensity;
          uniform float uRotationSpeed;
          uniform float uRepulsionStrength;
          uniform float uMouseActiveFactor;
          uniform float uAutoCenterRepulsion;
          uniform bool uTransparent;
          varying vec2 vUv;

          #define NUM_LAYER 4.0
          #define STAR_COLOR_CUTOFF 0.2
          #define MAT45 mat2(0.7071, -0.7071, 0.7071, 0.7071)
          #define PERIOD 3.0

          float Hash21(vec2 p) {
            p = fract(p * vec2(123.34, 456.21));
            p += dot(p, p + 45.32);
            return fract(p.x * p.y);
          }

          float tri(float x) {
            return abs(fract(x) * 2.0 - 1.0);
          }

          float tris(float x) {
            float t = fract(x);
            return 1.0 - smoothstep(0.0, 1.0, abs(2.0 * t - 1.0));
          }

          float trisn(float x) {
            float t = fract(x);
            return 2.0 * (1.0 - smoothstep(0.0, 1.0, abs(2.0 * t - 1.0))) - 1.0;
          }

          vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
          }

          float Star(vec2 uv, float flare) {
            float d = length(uv);
            float m = (0.05 * uGlowIntensity) / d;
            float rays = smoothstep(0.0, 1.0, 1.0 - abs(uv.x * uv.y * 1000.0));
            m += rays * flare * uGlowIntensity;
            uv *= MAT45;
            rays = smoothstep(0.0, 1.0, 1.0 - abs(uv.x * uv.y * 1000.0));
            m += rays * 0.3 * flare * uGlowIntensity;
            m *= smoothstep(1.0, 0.2, d);
            return m;
          }

          vec3 StarLayer(vec2 uv) {
            vec3 col = vec3(0.0);
            vec2 gv = fract(uv) - 0.5; 
            vec2 id = floor(uv);

            for (int y = -1; y <= 1; y++) {
              for (int x = -1; x <= 1; x++) {
                vec2 offset = vec2(float(x), float(y));
                vec2 si = id + vec2(float(x), float(y));
                float seed = Hash21(si);
                float size = fract(seed * 345.32);
                float glossLocal = tri(uStarSpeed / (PERIOD * seed + 1.0));
                float flareSize = smoothstep(0.9, 1.0, size) * glossLocal;

                // ‰ΩøÁî®ÁôΩËâ≤ÊòüÊòüÔºåÂ∏¶ÊúâËΩªÂæÆÁöÑÊ∏©Â∫¶ÂèòÂåñ
                float temperature = Hash21(si + 5.0);
                vec3 base;
                if (temperature > 0.7) {
                  // ËìùÁôΩËâ≤ÔºàÁÉ≠ÊòüÔºâ
                  base = vec3(0.9, 0.95, 1.0);
                } else if (temperature > 0.3) {
                  // Á∫ØÁôΩËâ≤Ôºà‰∏ªÂ∫èÊòüÔºâ
                  base = vec3(1.0, 1.0, 1.0);
                } else {
                  // ÊöñÁôΩËâ≤ÔºàÂÜ∑ÊòüÔºâ
                  base = vec3(1.0, 0.95, 0.9);
                }

                vec2 pad = vec2(tris(seed * 34.0 + uTime * uSpeed / 10.0), tris(seed * 38.0 + uTime * uSpeed / 30.0)) - 0.5;

                float star = Star(gv - offset - pad, flareSize);
                vec3 color = base;

                float twinkle = trisn(uTime * uSpeed + seed * 6.2831) * 0.5 + 1.0;
                twinkle = mix(1.0, twinkle, uTwinkleIntensity);
                star *= twinkle;
                
                col += star * size * color;
              }
            }
            return col;
          }

          void main() {
            vec2 focalPx = uFocal * uResolution.xy;
            vec2 uv = (vUv * uResolution.xy - focalPx) / uResolution.y;

            if (uMouseRepulsion) {
              vec2 mousePosUV = (uMouse * uResolution.xy - focalPx) / uResolution.y;
              float mouseDist = length(uv - mousePosUV);
              // ÂèØËßÅÁöÑ‰∫§‰∫íÊïàÊûúÔºöÈÄÇ‰∏≠ÁöÑÂΩ±ÂìçËåÉÂõ¥ÂíåÂº∫Â∫¶
              float influence = smoothstep(1.2, 0.0, mouseDist); // Êâ©Â§ßÂΩ±ÂìçËåÉÂõ¥
              vec2 repulsion = normalize(uv - mousePosUV) * (uRepulsionStrength * 0.8 / (mouseDist + 0.2));
              uv += repulsion * 0.05 * uMouseActiveFactor * influence; // Â¢ûÂä†Êï¥‰ΩìÂº∫Â∫¶
            }

            float autoRotAngle = uTime * uRotationSpeed;
            mat2 autoRot = mat2(cos(autoRotAngle), -sin(autoRotAngle), sin(autoRotAngle), cos(autoRotAngle));
            uv = autoRot * uv;

            uv = mat2(uRotation.x, -uRotation.y, uRotation.y, uRotation.x) * uv;

            vec3 col = vec3(0.0);

            for (float i = 0.0; i < 1.0; i += 1.0 / NUM_LAYER) {
              float depth = fract(i + uStarSpeed * uSpeed);
              float scale = mix(20.0 * uDensity, 0.5 * uDensity, depth);
              float fade = depth * smoothstep(1.0, 0.9, depth);
              col += StarLayer(uv * scale + i * 453.32) * fade;
            }

            float alpha = length(col);
            alpha = smoothstep(0.0, 0.3, alpha);
            alpha = min(alpha, 1.0);
            gl_FragColor = vec4(col, alpha);
          }
          `;

          useEffect(() => {
            if (!ctnDom.current) return;
            const ctn = ctnDom.current;
            
            try {
              const renderer = new Renderer({
                alpha: transparent,
                premultipliedAlpha: false,
              });
              const gl = renderer.gl;

              let program;

              function resize() {
                const scale = 1;
                renderer.setSize(ctn.offsetWidth * scale, ctn.offsetHeight * scale);
                if (program) {
                  program.uniforms.uResolution.value = new Color(
                    gl.canvas.width,
                    gl.canvas.height,
                    gl.canvas.width / gl.canvas.height
                  );
                }
              }
              window.addEventListener("resize", resize, false);
              resize();

              const geometry = new Triangle(gl);
              program = new Program(gl, {
                vertex: vertexShader,
                fragment: fragmentShader,
                uniforms: {
                  uTime: { value: 0 },
                  uResolution: {
                    value: new Color(
                      gl.canvas.width,
                      gl.canvas.height,
                      gl.canvas.width / gl.canvas.height
                    ),
                  },
                  uFocal: { value: new Float32Array(focal) },
                  uRotation: { value: new Float32Array(rotation) },
                  uStarSpeed: { value: starSpeed },
                  uDensity: { value: density },
                  uHueShift: { value: hueShift },
                  uSpeed: { value: speed },
                  uMouse: {
                    value: new Float32Array([
                      smoothMousePos.current.x,
                      smoothMousePos.current.y,
                    ]),
                  },
                  uGlowIntensity: { value: glowIntensity },
                  uSaturation: { value: saturation },
                  uMouseRepulsion: { value: mouseRepulsion },
                  uTwinkleIntensity: { value: twinkleIntensity },
                  uRotationSpeed: { value: rotationSpeed },
                  uRepulsionStrength: { value: repulsionStrength },
                  uMouseActiveFactor: { value: 0.0 },
                  uAutoCenterRepulsion: { value: autoCenterRepulsion },
                  uTransparent: { value: transparent },
                },
              });

              const mesh = new Mesh(gl, { geometry, program });
              let animateId;

              function update(t) {
                animateId = requestAnimationFrame(update);
                if (!disableAnimation) {
                  program.uniforms.uTime.value = t * 0.001;
                  program.uniforms.uStarSpeed.value = (t * 0.001 * starSpeed) / 10.0;
                }

                // ÊµãËØïÊ®°ÂºèÔºöÊåÅÁª≠Âú®‰∏≠ÂøÉ‰ΩçÁΩÆÊñΩÂä†Âº∫Â§ßÁöÑÈº†Ê†áÊïàÊûú
                if (testMode) {
                  targetMousePos.current = { x: 0.5, y: 0.5 };
                  targetMouseActive.current = 3.0; // Âº∫ÂäõÊïàÊûú
                  // ÊØè2ÁßíÊâìÂç∞‰∏ÄÊ¨°ÊµãËØïÊ®°ÂºèÁä∂ÊÄÅ
                  if (Math.floor(t / 2000) !== Math.floor((t - 16) / 2000)) {
                    console.log('üß™ ÊµãËØïÊ®°ÂºèËøêË°å‰∏≠: ÊåÅÁª≠Âº∫Âà∂ÊïàÊûú');
                  }
                }

                const lerpFactor = 0.03; // Êõ¥Âπ≥ÊªëÁöÑËøáÊ∏°
                smoothMousePos.current.x +=
                  (targetMousePos.current.x - smoothMousePos.current.x) * lerpFactor;
                smoothMousePos.current.y +=
                  (targetMousePos.current.y - smoothMousePos.current.y) * lerpFactor;

                smoothMouseActive.current +=
                  (targetMouseActive.current - smoothMouseActive.current) * lerpFactor;

                program.uniforms.uMouse.value[0] = smoothMousePos.current.x;
                program.uniforms.uMouse.value[1] = smoothMousePos.current.y;
                program.uniforms.uMouseActiveFactor.value = smoothMouseActive.current;
                
                // Ë∞ÉËØïÔºöÊØèÁßíÊòæÁ§∫‰∏ÄÊ¨°Èº†Ê†áÁä∂ÊÄÅ
                if (Math.floor(t / 1000) !== Math.floor((t - 16) / 1000)) {
                  console.log('Mouse state:', {
                    active: smoothMouseActive.current.toFixed(3),
                    pos: [smoothMousePos.current.x.toFixed(3), smoothMousePos.current.y.toFixed(3)],
                    repulsion: program.uniforms.uMouseRepulsion.value,
                    strength: program.uniforms.uRepulsionStrength.value
                  });
                }

                renderer.render({ scene: mesh });
              }
              animateId = requestAnimationFrame(update);
              ctn.appendChild(gl.canvas);
              
              console.log('Canvas info:', {
                element: gl.canvas,
                bounds: gl.canvas.getBoundingClientRect(),
                style: {
                  position: window.getComputedStyle(gl.canvas).position,
                  pointerEvents: window.getComputedStyle(gl.canvas).pointerEvents,
                  width: gl.canvas.style.width || gl.canvas.width,
                  height: gl.canvas.style.height || gl.canvas.height
                },
                parent: gl.canvas.parentElement
              });

              function handleMouseMove(e) {
                console.log('üî• handleMouseMove triggered!', {
                  type: e.type,
                  clientX: e.clientX,
                  clientY: e.clientY,
                  target: e.target,
                  currentTarget: e.currentTarget
                });
                const rect = ctn.getBoundingClientRect();
                const x = (e.clientX - rect.left) / rect.width;
                const y = 1.0 - (e.clientY - rect.top) / rect.height;
                
                console.log('üìç ËÆ°ÁÆóÁöÑÈº†Ê†á‰ΩçÁΩÆ:', { x, y, rect: rect });
                
                // Âè™Âú®ÈùûÊµãËØïÊ®°Âºè‰∏ãÊõ¥Êñ∞Èº†Ê†á‰ΩçÁΩÆ
                if (!testMode) {
                  targetMousePos.current = { x, y };
                  targetMouseActive.current = 1.0;
                  console.log('‚úÖ Êõ¥Êñ∞Èº†Ê†áÁä∂ÊÄÅ:', {
                    position: targetMousePos.current,
                    active: targetMouseActive.current
                  });
                } else {
                  console.log('‚ö†Ô∏è ÊµãËØïÊ®°ÂºèÂºÄÂêØÔºåÂøΩÁï•ÁúüÂÆûÈº†Ê†áËæìÂÖ•');
                }
              }

              function handleMouseLeave() {
                console.log('handleMouseLeave triggered!');
                targetMouseActive.current = 0.0;
              }

              console.log('Galaxy initialized with:', {
                mouseInteraction,
                mouseRepulsion,
                repulsionStrength,
                starSpeed,
                density,
                hueShift,
                glowIntensity,
                saturation
              });
              
              console.log('All uniforms:', Object.keys(program.uniforms).map(key => ({
                name: key,
                value: program.uniforms[key].value
              })));
              
              console.log('Container info:', {
                element: ctn,
                bounds: ctn.getBoundingClientRect(),
                style: {
                  position: window.getComputedStyle(ctn).position,
                  pointerEvents: window.getComputedStyle(ctn).pointerEvents,
                  width: window.getComputedStyle(ctn).width,
                  height: window.getComputedStyle(ctn).height
                }
              });

              // Ê∑ªÂä†‰∏Ä‰∏™ÈÄöÁî®ÁöÑÈº†Ê†áÊµãËØïÁõëÂê¨Âô®
              function testMouseMove(e) {
                console.log('TEST: Mouse detected on container at', e.clientX, e.clientY);
              }
              ctn.addEventListener("mousemove", testMouseMove);
              
              if (mouseInteraction) {
                ctn.addEventListener("mousemove", handleMouseMove);
                ctn.addEventListener("mouseleave", handleMouseLeave);
                console.log('Mouse event listeners added to container');
              } else {
                console.log('Mouse interaction disabled');
              }

              return () => {
                cancelAnimationFrame(animateId);
                window.removeEventListener("resize", resize);
                ctn.removeEventListener("mousemove", testMouseMove);
                if (mouseInteraction) {
                  ctn.removeEventListener("mousemove", handleMouseMove);
                  ctn.removeEventListener("mouseleave", handleMouseLeave);
                }
                if (ctn.contains(gl.canvas)) {
                  ctn.removeChild(gl.canvas);
                }
                gl.getExtension("WEBGL_lose_context")?.loseContext();
              };
            } catch (error) {
              console.error('GalaxyÁªÑ‰ª∂ÂàùÂßãÂåñÂ§±Ë¥•:', error);
            }
          }, [
            focal, rotation, starSpeed, density, hueShift, disableAnimation,
            speed, mouseInteraction, glowIntensity, saturation, mouseRepulsion,
            twinkleIntensity, rotationSpeed, repulsionStrength, autoCenterRepulsion, transparent, testMode,
          ]);

          return <div ref={ctnDom} style={{ width: '100%', height: '100%', position: 'relative' }} {...rest} />;
        }

        // ‰∏ªÂ∫îÁî®ÁªÑ‰ª∂
        function App() {
          const [config, setConfig] = useState({
            density: 1.5,
            hueShift: 0,
            glowIntensity: 0.6,
            saturation: 0.1,
            speed: 1.0,
            rotationSpeed: 0.1,
            repulsionStrength: 2.0,
            mouseInteraction: true
          });
          
          const [interactionEnabled, setInteractionEnabled] = useState(true);
          const [testMode, setTestMode] = useState(false);

          const presets = [
            { name: 'ÁªèÂÖ∏ÁôΩÊòü', density: 1.5, hueShift: 0, glowIntensity: 0.6, saturation: 0.1, speed: 1.0, repulsionStrength: 2.0 },
            { name: 'ÂØÜÈõÜÊòüÁ©∫', density: 2.5, hueShift: 0, glowIntensity: 0.8, saturation: 0.1, speed: 0.5, repulsionStrength: 1.5 },
            { name: 'Á®ÄÁñèÊ∑±Á©∫', density: 0.8, hueShift: 0, glowIntensity: 0.4, saturation: 0.1, speed: 1.5, repulsionStrength: 1.8 },
            { name: 'Êòé‰∫ÆÊòüÊ≤≥', density: 1.8, hueShift: 0, glowIntensity: 1.0, saturation: 0.1, speed: 0.8, repulsionStrength: 2.5 },
            { name: 'ÈùôË∞ßÂ§úÁ©∫', density: 1.0, hueShift: 0, glowIntensity: 0.3, saturation: 0.1, speed: 1.2, repulsionStrength: 1.0 }
          ];

          const applyPreset = (preset) => {
            setConfig({
              density: preset.density,
              hueShift: preset.hueShift,
              glowIntensity: preset.glowIntensity,
              saturation: preset.saturation,
              speed: preset.speed,
              rotationSpeed: 0.1,
              repulsionStrength: preset.repulsionStrength || 0.5,
              mouseInteraction: interactionEnabled
            });
          };

          // ÂàáÊç¢Èº†Ê†á‰∫§‰∫í
          const toggleInteraction = () => {
            const newInteractionState = !interactionEnabled;
            setInteractionEnabled(newInteractionState);
            setConfig(prevConfig => ({
              ...prevConfig,
              mouseInteraction: newInteractionState
            }));
            console.log('Èº†Ê†á‰∫§‰∫íÂ∑≤', newInteractionState ? 'ÂêØÁî®' : 'Á¶ÅÁî®');
          };

          // ÊµãËØïÊ®°ÂºèÔºöÂº∫Âà∂Ëß¶ÂèëÈº†Ê†áÊïàÊûú
          const toggleTestMode = () => {
            setTestMode(!testMode);
            console.log('ÊµãËØïÊ®°Âºè:', !testMode ? 'ÂºÄÂêØ' : 'ÂÖ≥Èó≠');
          };

          // Debug: Ê£ÄÊü•‰º†ÈÄíÁªôGalaxyÁöÑprops
          console.log('App config passed to Galaxy:', config);
          
          return (
            <div className="container">
              <div className="galaxy-background">
                <Galaxy 
                  starSpeed={config.speed}
                  density={config.density}
                  hueShift={config.hueShift}
                  glowIntensity={config.glowIntensity}
                  saturation={config.saturation}
                  rotationSpeed={config.rotationSpeed}
                  repulsionStrength={config.repulsionStrength}
                  mouseInteraction={config.mouseInteraction}
                  mouseRepulsion={true}
                  testMode={testMode}
                />
              </div>
              <div className="content">
                <h1 className="title">ÂÖâÂ≠êÁü©Èòµ</h1>
                <p className="subtitle">‰∏ì‰∏∫AIÊô∫ËÉΩËá™Âä®ÂåñËÄåÁîü</p>
                <div className="controls">
                  {presets.map((preset) => (
                    <button
                      key={preset.name}
                      className="btn"
                      onClick={() => applyPreset(preset)}
                    >
                      {preset.name}
                    </button>
                  ))}
                </div>
                
                <div className="interaction-controls" style={{ marginTop: '20px', padding: '15px', background: 'rgba(255,255,255,0.1)', borderRadius: '10px' }}>
                  <h3 style={{ color: 'white', marginBottom: '10px', fontSize: '16px' }}>‰∫§‰∫íÊéßÂà∂</h3>
                  <button
                    className="btn"
                    onClick={toggleInteraction}
                    style={{ 
                      backgroundColor: interactionEnabled ? '#4CAF50' : '#f44336',
                      marginRight: '10px'
                    }}
                  >
                    Èº†Ê†á‰∫§‰∫í: {interactionEnabled ? 'ÂºÄÂêØ' : 'ÂÖ≥Èó≠'}
                  </button>
                  <button
                    className="btn"
                    onClick={toggleTestMode}
                    style={{ 
                      backgroundColor: testMode ? '#FF9800' : '#607D8B'
                    }}
                  >
                    ÊµãËØïÊ®°Âºè: {testMode ? 'ÂºÄÂêØ' : 'ÂÖ≥Èó≠'}
                  </button>
                  <div style={{ marginTop: '10px', fontSize: '12px', color: '#ccc' }}>
                    <div>ÂΩìÂâçÁä∂ÊÄÅ: ‰∫§‰∫í {interactionEnabled ? '‚úì' : '‚úó'} | ÊµãËØï {testMode ? '‚úì' : '‚úó'}</div>
                    <div>ÊèêÁ§∫: ÁßªÂä®Èº†Ê†áËßÇÂØüÊòüÁ©∫ÂèçÂ∫î</div>
                  </div>
                  
                  {/* ËøõÂÖ•‰∏ªÈ°µÊåâÈíÆ */}
                  <div style={{ marginTop: '30px' }}>
                    <button
                      className="btn"
                      onClick={() => window.location.href = 'main.html'}
                      style={{ 
                        backgroundColor: '#4CAF50',
                        fontSize: '18px',
                        padding: '15px 30px',
                        border: '2px solid #4CAF50',
                        borderRadius: '30px',
                        color: 'white',
                        fontWeight: 'bold',
                        cursor: 'pointer',
                        transition: 'all 0.3s ease',
                        boxShadow: '0 0 20px rgba(76, 175, 80, 0.3)'
                      }}
                      onMouseEnter={(e) => {
                        e.target.style.backgroundColor = '#45a049';
                        e.target.style.boxShadow = '0 0 30px rgba(76, 175, 80, 0.5)';
                        e.target.style.transform = 'scale(1.05)';
                      }}
                      onMouseLeave={(e) => {
                        e.target.style.backgroundColor = '#4CAF50';
                        e.target.style.boxShadow = '0 0 20px rgba(76, 175, 80, 0.3)';
                        e.target.style.transform = 'scale(1)';
                      }}
                    >
                      üöÄ ËøõÂÖ•ÂÖâÂ≠êÁü©Èòµ
                    </button>
                  </div>
                </div>
              </div>
            </div>
          );
        }

        // Ê∏≤ÊüìÂ∫îÁî® - ‰ΩøÁî®React 18 API
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>